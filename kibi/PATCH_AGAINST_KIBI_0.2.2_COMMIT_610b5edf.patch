diff -ruPN kibi-master/Cargo.toml kibi-melda/Cargo.toml
--- kibi-master/Cargo.toml	2022-03-29 13:10:47.429576878 +0200
+++ kibi-melda/Cargo.toml	2022-05-31 08:58:56.652810764 +0200
@@ -13,6 +13,11 @@
 
 [dependencies]
 unicode-width = "0.1.8"
+serde_json = "1.0"
+url = "2.2.2"
+uuid = { version = "0.8", features = ["serde", "v4"] }
+env_logger = "0.9.0"
+melda = { git = "https://github.com/slashdotted/libmelda.git" }
 
 [target.'cfg(unix)'.dependencies]
 libc = "0.2.97"
diff -ruPN kibi-master/count_loc.sh kibi-melda/count_loc.sh
--- kibi-master/count_loc.sh	2022-03-29 13:10:47.433576918 +0200
+++ kibi-melda/count_loc.sh	2022-03-29 08:30:42.554797482 +0200
@@ -44,4 +44,4 @@
   exit 1
 else
   echo -e ' \x1b[32m(≤ 1024)\x1b[0m'
-fi
\ Manca newline alla fine del file
+fi
I file binari kibi-master/.git/index e kibi-melda/.git/index sono diversi
diff -ruPN kibi-master/.git/logs/HEAD kibi-melda/.git/logs/HEAD
--- kibi-master/.git/logs/HEAD	2022-03-29 13:10:47.437576958 +0200
+++ kibi-melda/.git/logs/HEAD	2022-03-29 08:30:37.514748065 +0200
@@ -1,2 +1,2 @@
-0000000000000000000000000000000000000000 dd8aa7bda1e40b09967118854ee37a9aa85267cd Amos Brocco <amos.brocco@gmail.com> 1648552235 +0200	clone: from https://github.com/ilai-deutel/kibi
-dd8aa7bda1e40b09967118854ee37a9aa85267cd 610b5edfadc25828b6068c4be98f0b0391957d4e Amos Brocco <amos.brocco@gmail.com> 1648552247 +0200	reset: moving to 610b5edf
+0000000000000000000000000000000000000000 dd8aa7bda1e40b09967118854ee37a9aa85267cd Amos Brocco <amos.brocco@gmail.com> 1648535429 +0200	clone: from https://github.com/ilai-deutel/kibi
+dd8aa7bda1e40b09967118854ee37a9aa85267cd 610b5edfadc25828b6068c4be98f0b0391957d4e Amos Brocco <amos.brocco@gmail.com> 1648535437 +0200	reset: moving to 610b5edf
diff -ruPN kibi-master/.git/logs/refs/heads/master kibi-melda/.git/logs/refs/heads/master
--- kibi-master/.git/logs/refs/heads/master	2022-03-29 13:10:47.437576958 +0200
+++ kibi-melda/.git/logs/refs/heads/master	2022-03-29 08:30:37.514748065 +0200
@@ -1,2 +1,2 @@
-0000000000000000000000000000000000000000 dd8aa7bda1e40b09967118854ee37a9aa85267cd Amos Brocco <amos.brocco@gmail.com> 1648552235 +0200	clone: from https://github.com/ilai-deutel/kibi
-dd8aa7bda1e40b09967118854ee37a9aa85267cd 610b5edfadc25828b6068c4be98f0b0391957d4e Amos Brocco <amos.brocco@gmail.com> 1648552247 +0200	reset: moving to 610b5edf
+0000000000000000000000000000000000000000 dd8aa7bda1e40b09967118854ee37a9aa85267cd Amos Brocco <amos.brocco@gmail.com> 1648535429 +0200	clone: from https://github.com/ilai-deutel/kibi
+dd8aa7bda1e40b09967118854ee37a9aa85267cd 610b5edfadc25828b6068c4be98f0b0391957d4e Amos Brocco <amos.brocco@gmail.com> 1648535437 +0200	reset: moving to 610b5edf
diff -ruPN kibi-master/.git/logs/refs/remotes/origin/HEAD kibi-melda/.git/logs/refs/remotes/origin/HEAD
--- kibi-master/.git/logs/refs/remotes/origin/HEAD	2022-03-29 13:10:35.665458447 +0200
+++ kibi-melda/.git/logs/refs/remotes/origin/HEAD	2022-03-29 08:30:29.166666217 +0200
@@ -1 +1 @@
-0000000000000000000000000000000000000000 dd8aa7bda1e40b09967118854ee37a9aa85267cd Amos Brocco <amos.brocco@gmail.com> 1648552235 +0200	clone: from https://github.com/ilai-deutel/kibi
+0000000000000000000000000000000000000000 dd8aa7bda1e40b09967118854ee37a9aa85267cd Amos Brocco <amos.brocco@gmail.com> 1648535429 +0200	clone: from https://github.com/ilai-deutel/kibi
diff -ruPN kibi-master/src/editor.rs kibi-melda/src/editor.rs
--- kibi-master/src/editor.rs	2022-03-29 13:10:47.433576918 +0200
+++ kibi-melda/src/editor.rs	2022-05-31 09:00:40.441850197 +0200
@@ -1,17 +1,28 @@
 #![allow(clippy::wildcard_imports)]
 
+use std::env;
 use std::io::{self, BufRead, BufReader, ErrorKind::NotFound, Read, Seek, Write};
 use std::iter::{self, repeat, successors};
+use std::sync::{Arc, RwLock};
 use std::{fmt::Display, fs::File, path::Path, process::Command, thread, time::Instant};
 
-use crate::row::{HlState, Row};
+use melda::{
+    adapter::Adapter, filesystemadapter::FilesystemAdapter, melda::Melda,
+    memoryadapter::MemoryAdapter, solidadapter::SolidAdapter,
+};
+use serde_json::{json, Map, Value};
+use url::Url;
+
+use crate::row::{HlState, Row, UuidChar};
 use crate::{ansi_escape::*, syntax::Conf as SyntaxConf, sys, terminal, Config, Error};
 
 const fn ctrl_key(key: u8) -> u8 { key & 0x1f }
 const EXIT: u8 = ctrl_key(b'Q');
 const DELETE_BIS: u8 = ctrl_key(b'H');
 const REFRESH_SCREEN: u8 = ctrl_key(b'L');
+const REFRESH_REPLICA: u8 = ctrl_key(b'R');
 const SAVE: u8 = ctrl_key(b'S');
+const SAVE_AS: u8 = ctrl_key(b'N');
 const FIND: u8 = ctrl_key(b'F');
 const GOTO: u8 = ctrl_key(b'G');
 const DUPLICATE: u8 = ctrl_key(b'D');
@@ -66,6 +77,11 @@
     coff: usize,
 }
 
+enum AdapterReadyFor {
+    LOADING,
+    SAVING,
+}
+
 /// The `Editor` struct, contains the state and configuration of the text editor.
 #[derive(Default)]
 pub struct Editor {
@@ -104,6 +120,18 @@
     n_bytes: u64,
     /// The original terminal mode. It will be restored when the `Editor` instance is dropped.
     orig_term_mode: Option<sys::TermMode>,
+    /// Local Document replica
+    local_replica: Option<Melda>,
+    /// Currently loaded url
+    remote_url: Option<Url>,
+    /// Remote Document replica
+    remote_replica: Option<Melda>,
+    /// Adapter status
+    ready_for: Option<AdapterReadyFor>,
+    // Username
+    username: Option<String>,
+    // Password
+    password: Option<String>,
 }
 
 /// Describes a status message, shown at the bottom at the screen.
@@ -150,6 +178,8 @@
     pub fn new(config: Config) -> Result<Self, Error> {
         sys::register_winsize_change_signal_handler()?;
         let mut editor = Self::default();
+        editor.initialize_local_replica();
+
         editor.quit_times = config.quit_times;
         editor.config = config;
 
@@ -162,18 +192,103 @@
         Ok(editor)
     }
 
+    fn initialize_local_replica(&mut self) {
+        // Initialize local replica
+        let adapter = Box::new(MemoryAdapter::new());
+        self.local_replica = Some(Melda::new(Arc::new(RwLock::new(adapter))).unwrap());
+    }
+
+    fn initialize_remote_replica(&mut self, url: &Url) {
+        if self.remote_url.is_none() || self.remote_url.as_ref().unwrap().ne(&url) {
+            let adapter: Box<dyn Adapter> = if url.scheme().eq("file") {
+                Box::new(FilesystemAdapter::new(url.path()).expect("cannot_initialize_adapter"))
+            } else if url.scheme().eq("solid") {
+                Box::new(
+                    SolidAdapter::new(
+                        "https://".to_string() + &url.host().unwrap().to_string(),
+                        url.path().to_string() + "/",
+                        self.username.clone(),
+                        self.password.clone(),
+                    )
+                    .expect("cannot_initialize_adapter"),
+                )
+            } else {
+                panic!("invalid_adapter");
+            };
+            self.remote_replica = Some(Melda::new(Arc::new(RwLock::new(adapter))).unwrap());
+            self.remote_url = Some(url.clone());
+        } else if self.remote_replica.is_some() {
+            self.remote_replica.as_mut().unwrap().reload().expect("cannot_reload");
+        }
+    }
+
+    fn serialize(&self) -> Map<String, Value> {
+        let mut rows = vec![];
+        for (_, row) in self.rows.iter().enumerate() {
+            let mut rowdata = Map::<String, Value>::new();
+            rowdata.insert("_id".to_string(), Value::from(row.uuid.clone()));
+            let mut rowchars = vec![];
+            for c in &row.chars {
+                let mut chardata = Map::<String, Value>::new();
+                chardata.insert("#".to_string(), Value::from(c.0.to_string()));
+                chardata.insert("_id".to_string(), Value::from(c.1.clone()));
+                rowchars.push(Value::from(chardata));
+            }
+            rowdata.insert("\u{0394}c\u{266D}".to_string(), Value::from(rowchars));
+            rows.push(Value::from(rowdata));
+        }
+        json!({ "\u{0394}rows\u{266D}": Value::from(rows) }).as_object().unwrap().clone()
+    }
+
+    fn deserialize(&mut self) -> u64 {
+        let mut total = 0;
+        match self.local_replica.as_ref().unwrap().read() {
+            Ok(data) => {
+                self.rows.clear();
+                let rows = data.get("\u{0394}rows\u{266D}").unwrap().as_array().unwrap();
+                for r in rows {
+                    let row = r.as_object().unwrap();
+                    let rid = row.get("_id").unwrap().as_str().unwrap();
+                    let rowchars = row.get("\u{0394}c\u{266D}").unwrap().as_array().unwrap();
+                    let mut chars = vec![];
+                    for c in rowchars {
+                        let chardata = c.as_object().unwrap();
+                        let cvalue =
+                            chardata.get("#").unwrap().as_str().unwrap().parse::<u8>().unwrap();
+                        let cid = chardata.get("_id").unwrap().as_str().unwrap();
+                        chars.push(UuidChar(cvalue, cid.to_string()));
+                        total += 1;
+                    }
+                    self.rows.push(Row::new(chars, Some(rid.to_string())));
+                }
+                self.update_all_rows();
+                self.update_screen_cols();
+                self.n_bytes = self.rows.iter().map(|row| row.chars.len() as u64).sum();
+            }
+            Err(e) => set_status!(self, "Error: {}", e),
+        }
+        total
+    }
+
     /// Return the current row if the cursor points to an existing row, `None` otherwise.
     fn current_row(&self) -> Option<&Row> { self.rows.get(self.cursor.y) }
 
     /// Return the position of the cursor, in terms of rendered characters (as opposed to
     /// `self.cursor.x`, which is the position of the cursor in terms of bytes).
-    fn rx(&self) -> usize { self.current_row().map_or(0, |r| r.cx2rx[self.cursor.x]) }
+    fn rx(&self) -> usize {
+        self.current_row().map_or(0, |r| {
+            let fpos = std::cmp::min(r.cx2rx.len() - 1, self.cursor.x);
+            r.cx2rx[fpos]
+        })
+    }
 
     /// Move the cursor following an arrow key (← → ↑ ↓).
     fn move_cursor(&mut self, key: &AKey) {
         match (key, self.current_row()) {
             (AKey::Left, Some(row)) if self.cursor.x > 0 =>
-                self.cursor.x -= row.get_char_size(row.cx2rx[self.cursor.x] - 1),
+                self.cursor.x -= row.get_char_size(
+                    row.cx2rx[std::cmp::max(row.cx2rx.len() - 1, self.cursor.x - 1)] - 1,
+                ),
             (AKey::Left, _) if self.cursor.y > 0 => {
                 // ← at the beginning of the line: move to the end of the previous line. The x
                 // position will be adjusted after this `match` to accommodate the current row
@@ -325,9 +440,9 @@
     /// position, add a new row and insert the byte.
     fn insert_byte(&mut self, c: u8) {
         if let Some(row) = self.rows.get_mut(self.cursor.y) {
-            row.chars.insert(self.cursor.x, c)
+            row.chars.insert(self.cursor.x, UuidChar::new(c, None))
         } else {
-            self.rows.push(Row::new(vec![c]));
+            self.rows.push(Row::new(vec![UuidChar::new(c, None)], None));
             // The number of rows has changed. The left padding may need to be updated.
             self.update_screen_cols();
         }
@@ -348,7 +463,7 @@
             self.update_row(self.cursor.y, false);
             (self.cursor.y + 1, new_chars)
         };
-        self.rows.insert(position, Row::new(new_row_chars));
+        self.rows.insert(position, Row::new(new_row_chars, None));
         self.update_row(position, false);
         self.update_screen_cols();
         self.cursor.y += 1;
@@ -362,7 +477,10 @@
     fn delete_char(&mut self) {
         if self.cursor.x > 0 {
             let row = &mut self.rows[self.cursor.y];
-            // Obtain the number of bytes to be removed: could be 1-4 (UTF-8 character size).
+            if self.cursor.x >= row.cx2rx.len() || row.cx2rx[self.cursor.x] <= 0 {
+                self.cursor.x = 0;
+                return;
+            }
             let n_bytes_to_remove = row.get_char_size(row.cx2rx[self.cursor.x] - 1);
             row.chars.splice(self.cursor.x - n_bytes_to_remove..self.cursor.x, iter::empty());
             self.update_row(self.cursor.y, false);
@@ -373,7 +491,9 @@
             let row = self.rows.remove(self.cursor.y);
             let previous_row = &mut self.rows[self.cursor.y - 1];
             self.cursor.x = previous_row.chars.len();
-            previous_row.chars.extend(&row.chars);
+            for c in row.chars {
+                previous_row.chars.push(c);
+            }
             self.update_row(self.cursor.y - 1, true);
             self.update_row(self.cursor.y, false);
             // The number of rows has changed. The left padding may need to be updated.
@@ -389,7 +509,7 @@
 
     fn duplicate_current_row(&mut self) {
         if let Some(row) = self.current_row() {
-            let new_row = Row::new(row.chars.clone());
+            let new_row = Row::new_from_new_chars(row.chars.iter().map(|x| x.0).collect(), None);
             self.n_bytes += new_row.chars.len() as u64;
             self.rows.insert(self.cursor.y + 1, new_row);
             self.update_row(self.cursor.y + 1, false);
@@ -403,44 +523,115 @@
     /// Try to load a file. If found, load the rows and update the render and syntax highlighting.
     /// If not found, do not return an error.
     fn load(&mut self, path: &Path) -> Result<(), Error> {
-        match File::open(path) {
-            Ok(file) => {
-                for line in BufReader::new(file).split(b'\n') {
-                    self.rows.push(Row::new(line?));
-                }
-                // If the file ends with an empty line or is empty, we need to append an empty row
-                // to `self.rows`. Unfortunately, BufReader::split doesn't yield an empty Vec in
-                // this case, so we need to check the last byte directly.
-                let mut file = File::open(path)?;
-                file.seek(io::SeekFrom::End(0))?;
-                if file.bytes().next().transpose()?.map_or(true, |b| b == b'\n') {
-                    self.rows.push(Row::new(Vec::new()));
+        match Url::parse(path.to_str().unwrap()) {
+            Ok(u) => {
+                self.ready_for = Some(AdapterReadyFor::LOADING);
+                if self.ensure_adapter_is_ready(path) {
+                    self.initialize_local_replica();
+                    self.initialize_remote_replica(&u);
+                    let dc = self.remote_replica.as_ref().unwrap();
+                    self.local_replica.as_mut().unwrap().meld(dc).expect("meld_from_remote_failed");
+                    self.local_replica.as_mut().unwrap().reload().expect("failed_to_reload");
+                    let total = self.deserialize();
+                    set_status!(self, "{} characters read", total);
+                    Ok(())
+                } else {
+                    Ok(())
                 }
-                self.update_all_rows();
-                // The number of rows has changed. The left padding may need to be updated.
-                self.update_screen_cols();
-                self.n_bytes = self.rows.iter().map(|row| row.chars.len() as u64).sum();
             }
-            Err(e) if e.kind() == NotFound => self.rows.push(Row::new(Vec::new())),
-            Err(e) => return Err(e.into()),
+            Err(_) => {
+                match File::open(path) {
+                    Ok(file) => {
+                        for line in BufReader::new(file).split(b'\n') {
+                            self.rows.push(Row::new_from_new_chars(line?, None));
+                        }
+                        // If the file ends with an empty line or is empty, we need to append an empty row
+                        // to `self.rows`. Unfortunately, BufReader::split doesn't yield an empty Vec in
+                        // this case, so we need to check the last byte directly.
+                        let mut file = File::open(path)?;
+                        file.seek(io::SeekFrom::End(0))?;
+                        if file.bytes().next().transpose()?.map_or(true, |b| b == b'\n') {
+                            self.rows.push(Row::new(Vec::new(), None));
+                        }
+                        self.update_all_rows();
+                        // The number of rows has changed. The left padding may need to be updated.
+                        self.update_screen_cols();
+                        self.n_bytes = self.rows.iter().map(|row| row.chars.len() as u64).sum();
+                    }
+                    Err(e) if e.kind() == NotFound => self.rows.push(Row::new(Vec::new(), None)),
+                    Err(e) => return Err(e.into()),
+                }
+                Ok(())
+            }
         }
-        Ok(())
     }
 
     /// Save the text to a file, given its name.
-    fn save(&self, file_name: &str) -> Result<usize, io::Error> {
-        let mut file = File::create(file_name)?;
-        let mut written = 0;
-        for (i, row) in self.rows.iter().enumerate() {
-            file.write_all(&row.chars)?;
-            written += row.chars.len();
-            if i != (self.rows.len() - 1) {
-                file.write_all(&[b'\n'])?;
-                written += 1
+    fn save(&mut self, file_name: &str) -> Result<String, io::Error> {
+        match Url::parse(file_name) {
+            Ok(u) => {
+                self.ready_for = Some(AdapterReadyFor::SAVING);
+                if self.ensure_adapter_is_ready(Path::new(file_name)) {
+                    // Update local replica from new content
+                    if self.dirty {
+                        let serialized_state = self.serialize();
+                        let json = serde_json::to_string(&serialized_state)?;
+                        self.local_replica
+                            .as_mut()
+                            .unwrap()
+                            .update(serialized_state)
+                            .expect("update_failed");
+                    }
+                    let commit_result = self
+                        .local_replica
+                        .as_mut()
+                        .unwrap()
+                        .commit(None)
+                        .expect("commit_failed");
+                    self.initialize_remote_replica(&u);
+                    // Update local replica to integrate remote changes
+                    let melded = self
+                        .local_replica
+                        .as_mut()
+                        .unwrap()
+                        .meld(self.remote_replica.as_ref().unwrap())
+                        .expect("meld_from_remote_failed");
+                    if !melded.is_empty() {
+                        // Something was obtained from the remote replica, reload
+                        self.local_replica.as_mut().unwrap().reload().expect("reload_failed");
+                        self.deserialize();
+                    }
+                    match commit_result {
+                        Some(bid) => {
+                            // Update remote replica
+                            self.remote_replica
+                                .as_mut()
+                                .unwrap()
+                                .meld(&self.local_replica.as_ref().unwrap())
+                                .expect("meld_to_remote_failed");
+                            Ok(bid)
+                        }
+                        None => Ok("Nothing".to_string()),
+                    }
+                } else {
+                    Ok("".to_string())
+                }
+            }
+            Err(_) => {
+                let mut file = File::create(file_name)?;
+                let mut written = 0;
+                for (i, row) in self.rows.iter().enumerate() {
+                    file.write_all(&row.chars.iter().map(|x| x.0).collect::<Vec<u8>>())?;
+                    written += row.chars.len();
+                    if i != (self.rows.len() - 1) {
+                        file.write_all(&[b'\n'])?;
+                        written += 1
+                    }
+                }
+                file.sync_all()?;
+                Ok(format_size(written as u64))
             }
         }
-        file.sync_all()?;
-        Ok(written)
     }
 
     /// Save the text to a file and handle all errors. Errors and success messages will be printed
@@ -449,7 +640,7 @@
         let saved = self.save(file_name);
         // Print error or success message to the status bar
         match saved.as_ref() {
-            Ok(w) => set_status!(self, "{} written to {}", format_size(*w as u64), file_name),
+            Ok(w) => set_status!(self, "{} written to {}", w, file_name),
             Err(err) => set_status!(self, "Can't save! I/O error: {}", err),
         }
         // If save was successful, set dirty to false.
@@ -595,6 +786,40 @@
                 self.delete_char()
             }
             Key::Escape | Key::Char(REFRESH_SCREEN) => (),
+            Key::Char(REFRESH_REPLICA) => {
+                if self.remote_replica.is_some() {
+                    // Update local replica from new content
+                    let serialized_state = self.serialize();
+                    let json = serde_json::to_string(&serialized_state).expect("cannot serialize");
+                    self.local_replica
+                        .as_mut()
+                        .unwrap()
+                        .update(serialized_state)
+                        .expect("update_failed");
+                    // Save the current stage
+                    let stage =
+                        self.local_replica.as_ref().unwrap().stage().expect("cannot_get_stage");
+                        let content = serde_json::to_string(&stage).unwrap();
+                    
+                    // Update local replica to integrate remote changes
+                    self
+                        .local_replica
+                        .as_mut()
+                        .unwrap()
+                        .meld(self.remote_replica.as_ref().unwrap())
+                        .expect("meld_from_remote_failed");
+                    self.local_replica.as_mut().unwrap().reload().expect("reload_failed");
+                    // Replay stage
+                    self.local_replica
+                        .as_mut()
+                        .unwrap()
+                        .replay_stage(&stage)
+                        .expect("failed_to_replay_stage");
+                    self.deserialize();
+                    // Reload again to clear stage
+                    self.local_replica.as_mut().unwrap().reload().expect("reload_failed");
+                }
+            }
             Key::Char(EXIT) => {
                 quit_times = self.quit_times - 1;
                 if !self.dirty || quit_times == 0 {
@@ -616,6 +841,7 @@
             Key::Char(GOTO) => prompt_mode = Some(PromptMode::GoTo(String::new())),
             Key::Char(DUPLICATE) => self.duplicate_current_row(),
             Key::Char(EXECUTE) => prompt_mode = Some(PromptMode::Execute(String::new())),
+            Key::Char(SAVE_AS) => prompt_mode = Some(PromptMode::Save(String::new())),
             Key::Char(c) => self.insert_byte(*c),
         }
         self.quit_times = quit_times;
@@ -632,7 +858,9 @@
         for _ in 0..num_rows {
             current = (current + if forward { 1 } else { num_rows - 1 }) % num_rows;
             let row = &mut self.rows[current];
-            if let Some(cx) = slice_find(&row.chars, query.as_bytes()) {
+            if let Some(cx) =
+                slice_find(&row.chars.iter().map(|x| x.0).collect::<Vec<u8>>(), query.as_bytes())
+            {
                 self.cursor.y = current as usize;
                 self.cursor.x = cx;
                 // Try to reset the column offset; if the match is after the offset, this
@@ -646,6 +874,15 @@
         None
     }
 
+    fn ensure_adapter_is_ready(&mut self, path: &Path) -> bool {
+        if path.starts_with("solid://") && self.username.is_none() {
+            self.prompt_mode = Some(PromptMode::Username(String::new()));
+            false
+        } else {
+            true
+        }
+    }
+
     /// If `file_name` is not None, load the file. Then run the text editor.
     ///
     /// # Errors
@@ -656,7 +893,7 @@
             self.select_syntax_highlight(path)?;
             self.load(path)?;
         } else {
-            self.rows.push(Row::new(Vec::new()));
+            self.rows.push(Row::new(Vec::new(), None));
         }
         self.file_name = file_name;
         loop {
@@ -701,6 +938,10 @@
     GoTo(String),
     /// Execute(prompt buffer)
     Execute(String),
+    /// Solid username
+    Username(String),
+    /// Solid password
+    Password(String),
 }
 
 // TODO: Use trait with mode_status_msg and process_keypress, implement the trait for separate
@@ -709,6 +950,8 @@
     /// Return the status message to print for the selected `PromptMode`.
     fn status_msg(&self) -> String {
         match self {
+            Self::Username(buffer) => format!("Username: {}", buffer),
+            Self::Password(buffer) => format!("Password: {}", "*".repeat(buffer.len())),
             Self::Save(buffer) => format!("Save as: {}", buffer),
             Self::Find(buffer, ..) => format!("Search (Use ESC/Arrows/Enter): {}", buffer),
             Self::GoTo(buffer) => format!("Enter line number[:column number]: {}", buffer),
@@ -725,6 +968,31 @@
                 PromptState::Cancelled => set_status!(ed, "Save aborted"),
                 PromptState::Completed(file_name) => ed.save_as(file_name)?,
             },
+            Self::Username(b) => match process_prompt_keypress(b, key) {
+                PromptState::Active(b) => return Ok(Some(Self::Username(b))),
+                PromptState::Cancelled => set_status!(ed, "No username"),
+                PromptState::Completed(username) => {
+                    ed.username = Some(username);
+                    ed.prompt_mode = Some(PromptMode::Password(String::new()));
+                    return Ok(ed.prompt_mode.take());
+                }
+            },
+            Self::Password(b) => match process_prompt_keypress(b, key) {
+                PromptState::Active(b) => return Ok(Some(Self::Password(b))),
+                PromptState::Cancelled => set_status!(ed, "No password"),
+                PromptState::Completed(password) => {
+                    ed.password = Some(password);
+                    let file_name = ed.file_name.as_ref().unwrap().clone();
+                    match ed.ready_for.as_ref().unwrap() {
+                        AdapterReadyFor::LOADING => {
+                            ed.load(&Path::new(file_name.as_str()))?;
+                        }
+                        AdapterReadyFor::SAVING => {
+                            ed.save(file_name.as_str()).unwrap();
+                        }
+                    };
+                }
+            },
             Self::Find(b, saved_cursor, last_match) => {
                 if let Some(row_idx) = last_match {
                     ed.rows[row_idx].match_segment = None
diff -ruPN kibi-master/src/main.rs kibi-melda/src/main.rs
--- kibi-master/src/main.rs	2022-03-29 13:10:47.433576918 +0200
+++ kibi-melda/src/main.rs	2022-03-29 08:30:42.558797521 +0200
@@ -9,6 +9,7 @@
 ///
 /// Any error that occur during the execution of the program will be returned by this function.
 fn main() -> Result<(), Error> {
+    env_logger::init();
     let mut args = std::env::args();
     match (args.nth(1), args.nth(2)) {
         (_, Some(_)) => return Err(Error::TooManyArguments(args.len() - 1)),
diff -ruPN kibi-master/src/row.rs kibi-melda/src/row.rs
--- kibi-master/src/row.rs	2022-03-29 13:10:47.437576958 +0200
+++ kibi-melda/src/row.rs	2022-03-31 10:37:06.025851569 +0200
@@ -6,6 +6,7 @@
 use std::iter::repeat;
 
 use unicode_width::UnicodeWidthChar;
+use uuid::Uuid;
 
 use crate::ansi_escape::{RESET_FMT, REVERSE_VIDEO};
 use crate::syntax::{Conf as SyntaxConf, HlType};
@@ -27,11 +28,21 @@
     fn default() -> Self { Self::Normal }
 }
 
+pub struct UuidChar(pub u8, pub String);
+
+impl UuidChar {
+    pub fn new(c: u8, uuid: Option<String>) -> Self {
+        Self(c, uuid.unwrap_or_else(|| Uuid::new_v4().to_simple().to_string()))
+    }
+}
+
 /// Represents a row of characters and how it is rendered.
 #[derive(Default)]
 pub struct Row {
+    // Row unique identifier
+    pub uuid: String,
     /// The characters of the row.
-    pub chars: Vec<u8>,
+    pub chars: Vec<UuidChar>,
     /// How the characters are rendered. In particular, tabs are converted into several spaces, and
     /// bytes may be combined into single UTF-8 characters.
     render: String,
@@ -49,7 +60,25 @@
 
 impl Row {
     /// Create a new row, containing characters `chars`.
-    pub fn new(chars: Vec<u8>) -> Self { Self { chars, cx2rx: vec![0], ..Self::default() } }
+    pub fn new(chars: Vec<UuidChar>, uuid: Option<String>) -> Self {
+        Self {
+            uuid: uuid.unwrap_or_else(|| Uuid::new_v4().to_simple().to_string()),
+            chars,
+            cx2rx: vec![0],
+            ..Self::default()
+        }
+    }
+
+    /// Create a new row, containing characters `chars`.
+    pub fn new_from_new_chars(chars: Vec<u8>, uuid: Option<String>) -> Self {
+        let chars = chars.iter().map(|x| UuidChar::new(*x, None)).collect();
+        Self {
+            uuid: uuid.unwrap_or_else(|| Uuid::new_v4().to_simple().to_string()),
+            chars,
+            cx2rx: vec![0],
+            ..Self::default()
+        }
+    }
 
     // TODO: Combine update and update_syntax
     /// Update the row: convert tabs into spaces and compute highlight symbols
@@ -59,7 +88,8 @@
         self.cx2rx.clear();
         self.rx2cx.clear();
         let (mut cx, mut rx) = (0, 0);
-        for c in String::from_utf8_lossy(&self.chars).chars() {
+        let onlychars: Vec<u8> = self.chars.iter().map(|x| x.0).collect();
+        for c in String::from_utf8_lossy(&onlychars).chars() {
             // The number of bytes used to store the character
             let n_bytes = c.len_utf8();
             // The number of rendered characters
