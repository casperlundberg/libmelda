diff --git a/Cargo.lock b/Cargo.lock
deleted file mode 100644
index 2b10f6d..0000000
--- a/Cargo.lock
+++ /dev/null
@@ -1,292 +0,0 @@
-# This file is automatically @generated by Cargo.
-# It is not intended for manual editing.
-[[package]]
-name = "bitflags"
-version = "1.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693"
-
-[[package]]
-name = "cfg-if"
-version = "0.1.10"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822"
-
-[[package]]
-name = "cfg-if"
-version = "1.0.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
-
-[[package]]
-name = "cloudabi"
-version = "0.0.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f"
-dependencies = [
- "bitflags",
-]
-
-[[package]]
-name = "getrandom"
-version = "0.2.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4060f4657be78b8e766215b02b18a2e862d83745545de804638e2b545e81aee6"
-dependencies = [
- "cfg-if 1.0.0",
- "libc",
- "wasi",
-]
-
-[[package]]
-name = "kibi"
-version = "0.2.2"
-dependencies = [
- "libc",
- "serial_test",
- "tempfile",
- "unicode-width",
- "winapi",
- "winapi-util",
-]
-
-[[package]]
-name = "lazy_static"
-version = "1.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
-
-[[package]]
-name = "libc"
-version = "0.2.97"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "12b8adadd720df158f4d70dfe7ccc6adb0472d7c55ca83445f6a5ab3e36f8fb6"
-
-[[package]]
-name = "lock_api"
-version = "0.3.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c4da24a77a3d8a6d4862d95f72e6fdb9c09a643ecdb402d754004a557f2bec75"
-dependencies = [
- "scopeguard",
-]
-
-[[package]]
-name = "parking_lot"
-version = "0.10.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d3a704eb390aafdc107b0e392f56a82b668e3a71366993b5340f5833fd62505e"
-dependencies = [
- "lock_api",
- "parking_lot_core",
-]
-
-[[package]]
-name = "parking_lot_core"
-version = "0.7.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d58c7c768d4ba344e3e8d72518ac13e259d7c7ade24167003b8488e10b6740a3"
-dependencies = [
- "cfg-if 0.1.10",
- "cloudabi",
- "libc",
- "redox_syscall 0.1.56",
- "smallvec",
- "winapi",
-]
-
-[[package]]
-name = "ppv-lite86"
-version = "0.2.10"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ac74c624d6b2d21f425f752262f42188365d7b8ff1aff74c82e45136510a4857"
-
-[[package]]
-name = "proc-macro2"
-version = "1.0.12"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8872cf6f48eee44265156c111456a700ab3483686b3f96df4cf5481c89157319"
-dependencies = [
- "unicode-xid",
-]
-
-[[package]]
-name = "quote"
-version = "1.0.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4c1f4b0efa5fc5e8ceb705136bfee52cfdb6a4e3509f770b478cd6ed434232a7"
-dependencies = [
- "proc-macro2",
-]
-
-[[package]]
-name = "rand"
-version = "0.8.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "18519b42a40024d661e1714153e9ad0c3de27cd495760ceb09710920f1098b1e"
-dependencies = [
- "libc",
- "rand_chacha",
- "rand_core",
- "rand_hc",
-]
-
-[[package]]
-name = "rand_chacha"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e12735cf05c9e10bf21534da50a147b924d555dc7a547c42e6bb2d5b6017ae0d"
-dependencies = [
- "ppv-lite86",
- "rand_core",
-]
-
-[[package]]
-name = "rand_core"
-version = "0.6.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c026d7df8b298d90ccbbc5190bd04d85e159eaf5576caeacf8741da93ccbd2e5"
-dependencies = [
- "getrandom",
-]
-
-[[package]]
-name = "rand_hc"
-version = "0.3.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3190ef7066a446f2e7f42e239d161e905420ccab01eb967c9eb27d21b2322a73"
-dependencies = [
- "rand_core",
-]
-
-[[package]]
-name = "redox_syscall"
-version = "0.1.56"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2439c63f3f6139d1b57529d16bc3b8bb855230c8efcc5d3a896c8bea7c3b1e84"
-
-[[package]]
-name = "redox_syscall"
-version = "0.2.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "05ec8ca9416c5ea37062b502703cd7fcb207736bc294f6e0cf367ac6fc234570"
-dependencies = [
- "bitflags",
-]
-
-[[package]]
-name = "remove_dir_all"
-version = "0.5.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4a83fa3702a688b9359eccba92d153ac33fd2e8462f9e0e3fdf155239ea7792e"
-dependencies = [
- "winapi",
-]
-
-[[package]]
-name = "scopeguard"
-version = "1.1.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
-
-[[package]]
-name = "serial_test"
-version = "0.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "e0bccbcf40c8938196944a3da0e133e031a33f4d6b72db3bda3cc556e361905d"
-dependencies = [
- "lazy_static",
- "parking_lot",
- "serial_test_derive",
-]
-
-[[package]]
-name = "serial_test_derive"
-version = "0.5.1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b2acd6defeddb41eb60bb468f8825d0cfd0c2a76bc03bfd235b6a1dc4f6a1ad5"
-dependencies = [
- "proc-macro2",
- "quote",
- "syn",
-]
-
-[[package]]
-name = "smallvec"
-version = "1.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c7cb5678e1615754284ec264d9bb5b4c27d2018577fd90ac0ceb578591ed5ee4"
-
-[[package]]
-name = "syn"
-version = "1.0.18"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "410a7488c0a728c7ceb4ad59b9567eb4053d02e8cc7f5c0e0eeeb39518369213"
-dependencies = [
- "proc-macro2",
- "quote",
- "unicode-xid",
-]
-
-[[package]]
-name = "tempfile"
-version = "3.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22"
-dependencies = [
- "cfg-if 1.0.0",
- "libc",
- "rand",
- "redox_syscall 0.2.4",
- "remove_dir_all",
- "winapi",
-]
-
-[[package]]
-name = "unicode-width"
-version = "0.1.8"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9337591893a19b88d8d87f2cec1e73fad5cdfd10e5a6f349f498ad6ea2ffb1e3"
-
-[[package]]
-name = "unicode-xid"
-version = "0.2.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c"
-
-[[package]]
-name = "wasi"
-version = "0.10.1+wasi-snapshot-preview1"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "93c6c3420963c5c64bca373b25e77acb562081b9bb4dd5bb864187742186cea9"
-
-[[package]]
-name = "winapi"
-version = "0.3.9"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
-dependencies = [
- "winapi-i686-pc-windows-gnu",
- "winapi-x86_64-pc-windows-gnu",
-]
-
-[[package]]
-name = "winapi-i686-pc-windows-gnu"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
-
-[[package]]
-name = "winapi-util"
-version = "0.1.5"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178"
-dependencies = [
- "winapi",
-]
-
-[[package]]
-name = "winapi-x86_64-pc-windows-gnu"
-version = "0.4.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
diff --git a/Cargo.toml b/Cargo.toml
index 2992c4e..a51b93a 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -13,6 +13,10 @@ include = ["src/**/*", "Cargo.toml", "LICENSE*", "COPYRIGHT"]
 
 [dependencies]
 unicode-width = "0.1.8"
+serde_json = "1.0"
+url = "2.2.2"
+uuid = { version = "0.8", features = ["serde", "v4"] }
+env_logger = "0.9.0"
 
 [target.'cfg(unix)'.dependencies]
 libc = "0.2.97"
@@ -28,3 +32,6 @@ serial_test = "0.5.1"
 [badges]
 travis-ci = { repository = "ilai-deutel/kibi", branch = "master" }
 maintenance = { status = "actively-developed" }
+
+[dependencies.melda]
+path = "libmelda"
diff --git a/count_loc.sh b/count_loc.sh
index a805178..7c3eb68 100755
--- a/count_loc.sh
+++ b/count_loc.sh
@@ -44,4 +44,4 @@ if [[ $total_loc -gt 1024 ]]; then
   exit 1
 else
   echo -e ' \x1b[32m(≤ 1024)\x1b[0m'
-fi
\ No newline at end of file
+fi
diff --git a/src/editor.rs b/src/editor.rs
index adbaeb7..5a1caa9 100644
--- a/src/editor.rs
+++ b/src/editor.rs
@@ -1,10 +1,14 @@
 #![allow(clippy::wildcard_imports)]
 
+use std::env;
 use std::io::{self, BufRead, BufReader, ErrorKind::NotFound, Read, Seek, Write};
 use std::iter::{self, repeat, successors};
+use std::sync::{Arc, RwLock};
 use std::{fmt::Display, fs::File, path::Path, process::Command, thread, time::Instant};
-
-use crate::row::{HlState, Row};
+use serde_json::{Map, Value, json};
+use url::Url;
+use melda::{adapter::Adapter,solidadapter::SolidAdapter,filesystemadapter::FilesystemAdapter,melda::Melda,memoryadapter::MemoryAdapter};
+use crate::row::{HlState, Row, UuidChar};
 use crate::{ansi_escape::*, syntax::Conf as SyntaxConf, sys, terminal, Config, Error};
 
 const fn ctrl_key(key: u8) -> u8 { key & 0x1f }
@@ -12,6 +16,7 @@ const EXIT: u8 = ctrl_key(b'Q');
 const DELETE_BIS: u8 = ctrl_key(b'H');
 const REFRESH_SCREEN: u8 = ctrl_key(b'L');
 const SAVE: u8 = ctrl_key(b'S');
+const SAVE_AS: u8 = ctrl_key(b'N');
 const FIND: u8 = ctrl_key(b'F');
 const GOTO: u8 = ctrl_key(b'G');
 const DUPLICATE: u8 = ctrl_key(b'D');
@@ -66,6 +71,11 @@ struct CursorState {
     coff: usize,
 }
 
+enum AdapterReadyFor {
+    LOADING,
+    SAVING
+}
+
 /// The `Editor` struct, contains the state and configuration of the text editor.
 #[derive(Default)]
 pub struct Editor {
@@ -104,6 +114,18 @@ pub struct Editor {
     n_bytes: u64,
     /// The original terminal mode. It will be restored when the `Editor` instance is dropped.
     orig_term_mode: Option<sys::TermMode>,
+    /// Local Document replica
+    local_replica : Option<Melda>,
+    /// Currently loaded url
+    remote_url : Option<Url>,
+    /// Remote Document replica
+    remote_replica : Option<Melda>,
+    /// Adapter status
+    ready_for : Option<AdapterReadyFor>,
+    // Username
+    username : Option<String>,
+    // Password
+    password : Option<String>,
 }
 
 /// Describes a status message, shown at the bottom at the screen.
@@ -150,6 +172,8 @@ impl Editor {
     pub fn new(config: Config) -> Result<Self, Error> {
         sys::register_winsize_change_signal_handler()?;
         let mut editor = Self::default();
+        editor.initialize_local_replica();
+
         editor.quit_times = config.quit_times;
         editor.config = config;
 
@@ -162,12 +186,84 @@ impl Editor {
         Ok(editor)
     }
 
+    fn initialize_local_replica(&mut self) {
+        // Initialize local replica
+        let adapter = Box::new(
+            MemoryAdapter::new()
+        );
+        self.local_replica = Some(Melda::new(Arc::new(RwLock::new(adapter))).unwrap());
+    }
+
+    fn initialize_remote_replica(&mut self, url : &Url) {
+        if self.remote_url.is_none() || self.remote_url.as_ref().unwrap().ne(&url) {
+            let adapter : Box<dyn Adapter> = if url.scheme().eq("file") {
+                Box::new(FilesystemAdapter::new(url.path()).expect("cannot_initialize_adapter"))
+            } else if url.scheme().eq("solid") {
+                Box::new(SolidAdapter::new("https://".to_string() + &url.host().unwrap().to_string(), 
+                url.path().to_string() + "/", self.username.clone(), self.password.clone()).expect("cannot_initialize_adapter"))
+            } else {
+                panic!("invalid_adapter");
+            };
+            self.remote_replica = Some(Melda::new(Arc::new(RwLock::new(adapter))).unwrap());
+            self.remote_url = Some(url.clone());
+        } else if self.remote_replica.is_some() {
+            self.remote_replica.as_mut().unwrap().reload().expect("cannot_reload");
+        }
+    }
+
+    fn serialize(&self) -> Map<String,Value> {
+        let mut rows = vec![];
+        for (_, row) in self.rows.iter().enumerate() {
+            let mut rowdata = Map::<String,Value>::new();
+            rowdata.insert("_id".to_string(), Value::from(row.uuid.clone()));
+            let mut rowchars = vec![];
+            for c in &row.chars {
+                let mut chardata = Map::<String,Value>::new();
+                chardata.insert("#".to_string(), Value::from(c.0.to_string()));
+                chardata.insert("_id".to_string(), Value::from(c.1.clone()));
+                rowchars.push(Value::from(chardata));
+            }
+            rowdata.insert("\u{0394}c\u{266D}".to_string(), Value::from(rowchars));
+            rows.push(Value::from(rowdata));
+        }
+        json!({"\u{0394}rows\u{266D}" : Value::from(rows) }).as_object().unwrap().clone()
+    }
+
+    fn deserialize(&mut self) -> u64 {
+        let mut total = 0;
+        match self.local_replica.as_ref().unwrap().read() {
+            Ok(data) => {
+                self.rows.clear();
+                let rows = data.get("\u{0394}rows\u{266D}").unwrap().as_array().unwrap();
+                for r in rows {
+                    let row = r.as_object().unwrap();
+                    let rid = row.get("_id").unwrap().as_str().unwrap();
+                    let rowchars = row.get("\u{0394}c\u{266D}").unwrap().as_array().unwrap();
+                    let mut chars = vec![];
+                    for c in rowchars {
+                        let chardata = c.as_object().unwrap();
+                        let cvalue = chardata.get("#").unwrap().as_str().unwrap().parse::<u8>().unwrap();
+                        let cid = chardata.get("_id").unwrap().as_str().unwrap();
+                        chars.push(UuidChar(cvalue, cid.to_string()));
+                        total += 1;                 
+                    }
+                    self.rows.push(Row::new(chars, Some(rid.to_string())));                    
+                }                
+                self.update_all_rows();
+                self.update_screen_cols();
+                self.n_bytes = self.rows.iter().map(|row| row.chars.len() as u64).sum();
+            },
+            Err(e) => set_status!(self, "Error: {}", e),
+        }
+        total
+    }
+
     /// Return the current row if the cursor points to an existing row, `None` otherwise.
     fn current_row(&self) -> Option<&Row> { self.rows.get(self.cursor.y) }
 
     /// Return the position of the cursor, in terms of rendered characters (as opposed to
     /// `self.cursor.x`, which is the position of the cursor in terms of bytes).
-    fn rx(&self) -> usize { self.current_row().map_or(0, |r| r.cx2rx[self.cursor.x]) }
+    fn rx(&self) -> usize { self.current_row().map_or(0, |r| { let fpos = std::cmp::min(r.cx2rx.len()-1, self.cursor.x); r.cx2rx[fpos] }) }
 
     /// Move the cursor following an arrow key (← → ↑ ↓).
     fn move_cursor(&mut self, key: &AKey) {
@@ -325,9 +421,9 @@ impl Editor {
     /// position, add a new row and insert the byte.
     fn insert_byte(&mut self, c: u8) {
         if let Some(row) = self.rows.get_mut(self.cursor.y) {
-            row.chars.insert(self.cursor.x, c)
+            row.chars.insert(self.cursor.x, UuidChar::new(c, None))
         } else {
-            self.rows.push(Row::new(vec![c]));
+            self.rows.push(Row::new(vec![UuidChar::new(c, None)], None));
             // The number of rows has changed. The left padding may need to be updated.
             self.update_screen_cols();
         }
@@ -348,7 +444,7 @@ impl Editor {
             self.update_row(self.cursor.y, false);
             (self.cursor.y + 1, new_chars)
         };
-        self.rows.insert(position, Row::new(new_row_chars));
+        self.rows.insert(position, Row::new(new_row_chars, None));
         self.update_row(position, false);
         self.update_screen_cols();
         self.cursor.y += 1;
@@ -362,7 +458,10 @@ impl Editor {
     fn delete_char(&mut self) {
         if self.cursor.x > 0 {
             let row = &mut self.rows[self.cursor.y];
-            // Obtain the number of bytes to be removed: could be 1-4 (UTF-8 character size).
+            if self.cursor.x >= row.cx2rx.len() || row.cx2rx[self.cursor.x] <= 0 {
+                self.cursor.x = 0;
+                return
+            }
             let n_bytes_to_remove = row.get_char_size(row.cx2rx[self.cursor.x] - 1);
             row.chars.splice(self.cursor.x - n_bytes_to_remove..self.cursor.x, iter::empty());
             self.update_row(self.cursor.y, false);
@@ -373,7 +472,9 @@ impl Editor {
             let row = self.rows.remove(self.cursor.y);
             let previous_row = &mut self.rows[self.cursor.y - 1];
             self.cursor.x = previous_row.chars.len();
-            previous_row.chars.extend(&row.chars);
+            for c in row.chars {
+                previous_row.chars.push(c);
+            }
             self.update_row(self.cursor.y - 1, true);
             self.update_row(self.cursor.y, false);
             // The number of rows has changed. The left padding may need to be updated.
@@ -389,7 +490,7 @@ impl Editor {
 
     fn duplicate_current_row(&mut self) {
         if let Some(row) = self.current_row() {
-            let new_row = Row::new(row.chars.clone());
+            let new_row = Row::new_from_new_chars(row.chars.iter().map(|x| x.0).collect(), None);
             self.n_bytes += new_row.chars.len() as u64;
             self.rows.insert(self.cursor.y + 1, new_row);
             self.update_row(self.cursor.y + 1, false);
@@ -400,56 +501,111 @@ impl Editor {
         }
     }
 
-    /// Try to load a file. If found, load the rows and update the render and syntax highlighting.
+/// Try to load a file. If found, load the rows and update the render and syntax highlighting.
     /// If not found, do not return an error.
     fn load(&mut self, path: &Path) -> Result<(), Error> {
-        match File::open(path) {
-            Ok(file) => {
-                for line in BufReader::new(file).split(b'\n') {
-                    self.rows.push(Row::new(line?));
+        match Url::parse(path.to_str().unwrap()) {
+            Ok(u) => {
+                self.ready_for = Some(AdapterReadyFor::LOADING);
+                if self.ensure_adapter_is_ready(path) {
+                    self.initialize_local_replica();
+                    self.initialize_remote_replica(&u);
+                    let dc = self.remote_replica.as_ref().unwrap();
+                    self.local_replica.as_mut().unwrap().meld(dc).expect("meld_from_remote_failed");
+                    self.local_replica.as_mut().unwrap().reload().expect("failed_to_reload");
+                    let total = self.deserialize();
+                    set_status!(self, "{} characters read", total);
+                    Ok(())
+                } else {
+                    Ok(())
                 }
-                // If the file ends with an empty line or is empty, we need to append an empty row
-                // to `self.rows`. Unfortunately, BufReader::split doesn't yield an empty Vec in
-                // this case, so we need to check the last byte directly.
-                let mut file = File::open(path)?;
-                file.seek(io::SeekFrom::End(0))?;
-                if file.bytes().next().transpose()?.map_or(true, |b| b == b'\n') {
-                    self.rows.push(Row::new(Vec::new()));
+            }
+            Err(_) => {
+                match File::open(path) {
+                    Ok(file) => {
+                        for line in BufReader::new(file).split(b'\n') {
+                            self.rows.push(Row::new_from_new_chars(line?, None));
+                        }
+                        // If the file ends with an empty line or is empty, we need to append an empty row
+                        // to `self.rows`. Unfortunately, BufReader::split doesn't yield an empty Vec in
+                        // this case, so we need to check the last byte directly.
+                        let mut file = File::open(path)?;
+                        file.seek(io::SeekFrom::End(0))?;
+                        if file.bytes().next().transpose()?.map_or(true, |b| b == b'\n') {
+                            self.rows.push(Row::new(Vec::new(), None));
+                        }
+                        self.update_all_rows();
+                        // The number of rows has changed. The left padding may need to be updated.
+                        self.update_screen_cols();
+                        self.n_bytes = self.rows.iter().map(|row| row.chars.len() as u64).sum();
+                    }
+                    Err(e) if e.kind() == NotFound => self.rows.push(Row::new(Vec::new(), None)),
+                    Err(e) => return Err(e.into()),
                 }
-                self.update_all_rows();
-                // The number of rows has changed. The left padding may need to be updated.
-                self.update_screen_cols();
-                self.n_bytes = self.rows.iter().map(|row| row.chars.len() as u64).sum();
+                Ok(())
             }
-            Err(e) if e.kind() == NotFound => self.rows.push(Row::new(Vec::new())),
-            Err(e) => return Err(e.into()),
         }
-        Ok(())
     }
 
     /// Save the text to a file, given its name.
-    fn save(&self, file_name: &str) -> Result<usize, io::Error> {
-        let mut file = File::create(file_name)?;
-        let mut written = 0;
-        for (i, row) in self.rows.iter().enumerate() {
-            file.write_all(&row.chars)?;
-            written += row.chars.len();
-            if i != (self.rows.len() - 1) {
-                file.write_all(&[b'\n'])?;
-                written += 1
+    fn save(&mut self, file_name: &str) -> Result<String, io::Error> {
+        match Url::parse(file_name) {
+            Ok(u) => {
+                self.ready_for = Some(AdapterReadyFor::SAVING);
+                if self.ensure_adapter_is_ready(Path::new(file_name)) {
+                    let serialized_state = self.serialize();
+                    // Update local replica from new content
+                    if self.dirty {
+                        self.local_replica.as_mut().unwrap().update(serialized_state).expect("update_failed");
+                    }
+                    let commit_result = self.local_replica.as_mut().unwrap().commit(None, false).expect("commit_failed");
+                    self.initialize_remote_replica(&u);
+                    // Update local replica to integrate remote changes
+                    let melded = self.local_replica.as_mut().unwrap().meld(self.remote_replica.as_ref().unwrap()).expect("meld_from_remote_failed");
+                    if ! melded.is_empty() {
+                        // Something was obtained from the remote replica, reload
+                        self.local_replica.as_mut().unwrap().reload().expect("reload_failed");
+                        self.deserialize();                 
+                    }                
+                    match commit_result {
+                        Some(bid) => {
+                            // Update remote replica
+                            self.remote_replica.as_mut().unwrap().meld(&self.local_replica.as_mut().unwrap()).expect("meld_to_remote_failed");
+                            Ok(bid)
+                        },
+                        None => {
+                            Ok("Nothing".to_string())
+                        },
+                    }
+                } else {
+                    Ok("".to_string())
+                }
+            }
+            Err(_) => {
+                let mut file = File::create(file_name)?;
+                let mut written = 0;
+                for (i, row) in self.rows.iter().enumerate() {
+                    file.write_all(&row.chars.iter().map(|x| x.0).collect::<Vec<u8>>())?;
+                    written += row.chars.len();
+                    if i != (self.rows.len() - 1) {
+                        file.write_all(&[b'\n'])?;
+                        written += 1
+                    }
+                }
+                file.sync_all()?;
+                Ok(format_size(written as u64))
             }
         }
-        file.sync_all()?;
-        Ok(written)
     }
 
+
     /// Save the text to a file and handle all errors. Errors and success messages will be printed
     /// to the status bar. Return whether the file was successfully saved.
     fn save_and_handle_io_errors(&mut self, file_name: &str) -> bool {
         let saved = self.save(file_name);
         // Print error or success message to the status bar
         match saved.as_ref() {
-            Ok(w) => set_status!(self, "{} written to {}", format_size(*w as u64), file_name),
+            Ok(w) => set_status!(self, "{} written to {}", w, file_name),
             Err(err) => set_status!(self, "Can't save! I/O error: {}", err),
         }
         // If save was successful, set dirty to false.
@@ -602,7 +758,7 @@ impl Editor {
                 }
                 let times = if quit_times > 1 { "times" } else { "time" };
                 set_status!(self, "Press Ctrl+Q {} more {} to quit.", quit_times, times);
-            }
+            },
             Key::Char(SAVE) => match self.file_name.take() {
                 // TODO: Can we avoid using take() then reassigning the value to file_name?
                 Some(file_name) => {
@@ -616,6 +772,7 @@ impl Editor {
             Key::Char(GOTO) => prompt_mode = Some(PromptMode::GoTo(String::new())),
             Key::Char(DUPLICATE) => self.duplicate_current_row(),
             Key::Char(EXECUTE) => prompt_mode = Some(PromptMode::Execute(String::new())),
+            Key::Char(SAVE_AS) => prompt_mode = Some(PromptMode::Save(String::new())),
             Key::Char(c) => self.insert_byte(*c),
         }
         self.quit_times = quit_times;
@@ -632,7 +789,7 @@ impl Editor {
         for _ in 0..num_rows {
             current = (current + if forward { 1 } else { num_rows - 1 }) % num_rows;
             let row = &mut self.rows[current];
-            if let Some(cx) = slice_find(&row.chars, query.as_bytes()) {
+            if let Some(cx) = slice_find(&row.chars.iter().map(|x| x.0).collect::<Vec<u8>>(), query.as_bytes()) {
                 self.cursor.y = current as usize;
                 self.cursor.x = cx;
                 // Try to reset the column offset; if the match is after the offset, this
@@ -646,6 +803,15 @@ impl Editor {
         None
     }
 
+    fn ensure_adapter_is_ready(&mut self, path : &Path) -> bool {
+        if path.starts_with("solid://") && self.username.is_none() {
+            self.prompt_mode = Some(PromptMode::Username(String::new()));
+            false
+        } else {
+            true
+        }
+    }
+
     /// If `file_name` is not None, load the file. Then run the text editor.
     ///
     /// # Errors
@@ -656,7 +822,7 @@ impl Editor {
             self.select_syntax_highlight(path)?;
             self.load(path)?;
         } else {
-            self.rows.push(Row::new(Vec::new()));
+            self.rows.push(Row::new(Vec::new(), None));
         }
         self.file_name = file_name;
         loop {
@@ -701,6 +867,10 @@ enum PromptMode {
     GoTo(String),
     /// Execute(prompt buffer)
     Execute(String),
+    /// Solid username
+    Username(String),
+    /// Solid password
+    Password(String)
 }
 
 // TODO: Use trait with mode_status_msg and process_keypress, implement the trait for separate
@@ -709,6 +879,8 @@ impl PromptMode {
     /// Return the status message to print for the selected `PromptMode`.
     fn status_msg(&self) -> String {
         match self {
+            Self::Username(buffer) => format!("Username: {}", buffer),
+            Self::Password(buffer) => format!("Password: {}", "*".repeat(buffer.len())),
             Self::Save(buffer) => format!("Save as: {}", buffer),
             Self::Find(buffer, ..) => format!("Search (Use ESC/Arrows/Enter): {}", buffer),
             Self::GoTo(buffer) => format!("Enter line number[:column number]: {}", buffer),
@@ -725,6 +897,27 @@ impl PromptMode {
                 PromptState::Cancelled => set_status!(ed, "Save aborted"),
                 PromptState::Completed(file_name) => ed.save_as(file_name)?,
             },
+            Self::Username(b) => match process_prompt_keypress(b, key) {
+                PromptState::Active(b) => return Ok(Some(Self::Username(b))),
+                PromptState::Cancelled => set_status!(ed, "No username"),
+                PromptState::Completed(username) => {
+                    ed.username = Some(username);
+                    ed.prompt_mode = Some(PromptMode::Password(String::new()));
+                    return Ok(ed.prompt_mode.take());
+                }
+            },
+            Self::Password(b) => match process_prompt_keypress(b, key) {
+                PromptState::Active(b) => return Ok(Some(Self::Password(b))),
+                PromptState::Cancelled => set_status!(ed, "No password"),
+                PromptState::Completed(password) => {
+                    ed.password = Some(password);
+                    let file_name = ed.file_name.as_ref().unwrap().clone();
+                    match ed.ready_for.as_ref().unwrap() {
+                        AdapterReadyFor::LOADING => {ed.load(&Path::new(file_name.as_str()))?;},
+                        AdapterReadyFor::SAVING => {ed.save(file_name.as_str()).unwrap();},
+                    };
+                }
+            },            
             Self::Find(b, saved_cursor, last_match) => {
                 if let Some(row_idx) = last_match {
                     ed.rows[row_idx].match_segment = None
diff --git a/src/main.rs b/src/main.rs
index 8267fee..b0a31f7 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -9,6 +9,7 @@ use kibi::{Config, Editor, Error};
 ///
 /// Any error that occur during the execution of the program will be returned by this function.
 fn main() -> Result<(), Error> {
+    env_logger::init();
     let mut args = std::env::args();
     match (args.nth(1), args.nth(2)) {
         (_, Some(_)) => return Err(Error::TooManyArguments(args.len() - 1)),
diff --git a/src/row.rs b/src/row.rs
index 72b0a69..6356190 100644
--- a/src/row.rs
+++ b/src/row.rs
@@ -9,6 +9,7 @@ use unicode_width::UnicodeWidthChar;
 
 use crate::ansi_escape::{RESET_FMT, REVERSE_VIDEO};
 use crate::syntax::{Conf as SyntaxConf, HlType};
+use uuid::Uuid;
 
 /// The "Highlight State" of the row
 #[derive(Clone, Copy, PartialEq)]
@@ -27,11 +28,21 @@ impl Default for HlState {
     fn default() -> Self { Self::Normal }
 }
 
+pub struct UuidChar(pub u8, pub String);
+
+impl UuidChar {
+    pub fn new(c : u8, uuid : Option<String>) -> Self {
+            Self(c, uuid.unwrap_or_else(|| Uuid::new_v4().to_simple().to_string()))
+    }
+}
+
 /// Represents a row of characters and how it is rendered.
 #[derive(Default)]
 pub struct Row {
+    // Row unique identifier
+    pub uuid: String,
     /// The characters of the row.
-    pub chars: Vec<u8>,
+    pub chars: Vec<UuidChar>,
     /// How the characters are rendered. In particular, tabs are converted into several spaces, and
     /// bytes may be combined into single UTF-8 characters.
     render: String,
@@ -49,7 +60,15 @@ pub struct Row {
 
 impl Row {
     /// Create a new row, containing characters `chars`.
-    pub fn new(chars: Vec<u8>) -> Self { Self { chars, cx2rx: vec![0], ..Self::default() } }
+    pub fn new(chars: Vec<UuidChar>, uuid : Option<String>) -> Self {
+        Self { uuid : uuid.unwrap_or_else(|| Uuid::new_v4().to_simple().to_string()), chars, cx2rx: vec![0], ..Self::default() }
+    }
+
+    /// Create a new row, containing characters `chars`.
+    pub fn new_from_new_chars(chars: Vec<u8>, uuid : Option<String>) -> Self { 
+        let chars = chars.iter().map(|x| UuidChar::new(*x, None)).collect();
+        Self { uuid : uuid.unwrap_or_else(|| Uuid::new_v4().to_simple().to_string()), chars, cx2rx: vec![0], ..Self::default() }
+    }
 
     // TODO: Combine update and update_syntax
     /// Update the row: convert tabs into spaces and compute highlight symbols
@@ -59,7 +78,8 @@ impl Row {
         self.cx2rx.clear();
         self.rx2cx.clear();
         let (mut cx, mut rx) = (0, 0);
-        for c in String::from_utf8_lossy(&self.chars).chars() {
+        let onlychars: Vec<u8> = self.chars.iter().map(|x| x.0).collect();
+        for c in String::from_utf8_lossy(&onlychars).chars() {
             // The number of bytes used to store the character
             let n_bytes = c.len_utf8();
             // The number of rendered characters
